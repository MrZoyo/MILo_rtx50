# clean\_3dgs.py设计蓝图

目标：输入一个大场景的3DGaussianSplatting模型，自动裁掉那些不重要、很稀疏、很糙的外围区域，只保留核心部分，然后导出结果。

---

## 0.背景与目标

我们当前的3DGS是从一个大范围实地扫描得到的：广场是高优先级区域，拍得多、近距离、细节高；广场之外（马路、码头）是低优先级区域，拍得少、远距离、细节糙。

标准3DGS表示法（Kerbletal.2023之后的常规形式）里，每个“高斯”就是一个各向异性的3D椭球，带有这些属性：

*   中心点位置`(x,y,z)`（世界坐标，单位通常是米或类似尺度）
    
*   尺度/半轴长度`(sx,sy,sz)`或等价参数，用来描述它的体积/空间覆盖范围
    
*   方向（旋转矩阵/四元数/SH主方向）
    
*   颜色/不透明度等渲染属性
    

经验规律：

*   被相机近距离大量观测的部分，会出现更多高斯，且这些高斯更“小更精细”。
    
*   远处/很少扫到的部分，高斯稀疏、而且单个高斯会更“胖”（体积更大，用少量低分辨率大泡泡去解释远景）。
    

我们想要做的，就是利用这些统计差异，把“重点区域”自动保留下来，而把“低价值外围”整体裁掉。

更具体地，脚本要实现：

1.  把整个3DGS场景划分成一堆立方体小格（voxel分块，像3D魔方）。
    
2.  统计每个小格里的高斯分布特征。
    
3.  根据统计特征决定哪些格子属于“应该保留的区域”。
    
4.  删除“不重要格子”里的高斯。
    
5.  处理边界/细杆子之类的特殊情况，避免把我们其实想保留的东西误删。
    
6.  输出一个“干净版”的3DGS（同格式），并可选地导出网格（OBJ/STL）。
    

---

## 1.预期的输入/输出接口

### 输入

*   主输入：一个3DGS点云/高斯云文件  
    通常是`.ply`，里面一行/一条记录就是一个高斯，至少包含：
    
    *   `x,y,z`
        
    *   三个尺度参数（可以叫`scale_x/scale_y/scale_z`或`scale`,`rot`,`covariance_xx...`;细节随你的格式）
        
    *   颜色/不透明度等我们可以原样透传
        
    
    假设这些字段是可以被读出来放到内存中的。
    
*   可选参数（命令行或函数参数）：
    
    *   `voxel_size`:体素边长，决定分块粒度。当前脚本默认 **0.25m**；缩小时能捕捉薄片结构，但要同步考虑`halo_voxels`带来的物理膨胀厚度。
        
    *   `density_keep_ratio`:决定“密度阈值”的比例。默认 **0.30**，越小越宽松，能保留稀疏区域，但也会留下更多噪声小岛。
        
    *   `density_reference_percentile`:用于估计高密度参考的排名百分比。默认 **0.10**，即取最密集的前10%体素来求参考密度。
        
    *   `volume_keep_ratio`:决定“高精细体素”的体积阈值比例，详见第4节。默认 **3.0**，表示体素平均体积只要不超过超精细参考的3倍就可被细节守护逻辑保留。
        
    *   `volume_reference_percentile`:用来抽取“超精细”体素的比例。默认 **0.15**，即最小15%的`avg_volume`用于建立精细参考值。
        
    *   `halo_voxels`:保护带膨胀半径（整数，单位=体素数）。默认 **3**；体素越小，需要的halo步数通常越大才能保证同等物理厚度。
        
    *   `max_gaussians`:（可选）清理完后最多保留多少高斯。如果数量仍然太多，就做最后一步的随机/优先采样。
        
    *   `disable_component_filter`:布尔开关。默认不开，表示会自动剔除与主体不连通的小岛；开启后保留所有连通块。
        

这些参数中，`voxel_size`,`density_keep_ratio`,`halo_voxels`最直接决定裁剪范围；`density_reference_percentile`与`volume_reference_percentile`则细化阈值自适应，常常需要和前三者联动调整。

### 输出

*   一个新的3DGS文件（同输入格式，比如`.ply`），但只含“被保留”的高斯。
    

---

## 2.总体流水线（高层概览）

整个脚本逻辑分成8个阶段：

1.  **读取数据**  
    读入原始3DGS文件，提取每个高斯的：
    
    *   坐标`xyz`
        
    *   尺度信息（用来估计体积/大小）
        
    *   其它属性（原样保存，以便最终写回）
        
2.  **统计全局范围**  
    找到所有高斯的包围盒（boundingbox），用于后面的体素划分。
    
3.  **建立体素网格索引**  
    用`voxel_size`把整个包围盒量化成3D网格坐标`(i,j,k)`，并把每个高斯分配到它所在的体素。
    
4.  **为每个体素计算特征**  
    对每个体素，计算：
    
    *   `count`:这个小格里有多少个高斯
        
    *   `avg_volume`:这些高斯的平均体积（高斯大小）
        
    *   （可存更多：中位数体积、最大体积、透明度均值等，看你需要）
        
5.  **根据密度和高斯大小做第一次筛选**  
    目标：打上标签“保留/丢弃”到每个体素。
    
    *   密度很高的体素→保留
        
    *   密度低但平均高斯体积很小（意味着这是高精度、细杆子那类局部结构）→也保留
        
    *   其他→丢弃  
        这样可以避免“孤立柱子被删”的问题。
        
6.  **空间膨胀(halo)**  
    目标：避免硬切边界。  
    把“保留体素”做一层或多层空间膨胀：凡是靠近保留体素的邻居体素，也一并标记为保留。  
    这相当于在三维上做一个max-pooling风格的3×3×3(或更大核)膨胀操作。
    
7.  **回写到高斯层面**  
    只保留落在“保留体素”里的高斯，丢弃剩下的高斯。  
    如果还指定了`max_gaussians`，在这一层之后再做一次下采样。
    
8.  **导出**
    
    *   写新的3DGS（.ply）
        

---

## 3.细节设计

### 3.1读取与内部表示

把每个高斯存成一条结构体/记录，包含：

*   `pos=(x,y,z)`
    
*   `scale=(sx,sy,sz)`：这是高斯主轴方向上的标准差/半径。不同实现里名字可能叫`scale`,`covA`,`covB`，或者通过log-scale存的。只要能把它变成三个实际长度。
    
*   旋转/方向信息（保持原样，不一定要用到）
    
*   颜色/不透明度等视觉属性（保持原样）
    
*   一个唯一的index（方便之后回写）
    

这些数据要被全部读进内存，以便进行分组和过滤。

如果文件非常大（几百万高斯），内存还是够的（几百万行的float通常是几百MB级别，现代工作站可以撑）。如果特别极端，才需要分块流式处理；本设计先默认全量载入内存。

### 3.2统计全局范围(boundingbox)

对所有高斯的`(x,y,z)`分别取最小值和最大值，得到：

*   `min_x,min_y,min_z`
    
*   `max_x,max_y,max_z`
    

稍微往外扩一丢丢（比如加/减一个很小的epsilon），避免边界精度问题。

这个包围盒决定了体素网格的整体尺寸：  
网格大小大约是

*   `nx=ceil((max_x-min_x)/voxel_size)`
    
*   `ny=ceil((max_y-min_y)/voxel_size)`
    
*   `nz=ceil((max_z-min_z)/voxel_size)`
    

### 3.3把每个高斯映射到体素(voxelization)

体素坐标`(i,j,k)`的计算：

1.  对每个高斯中心`(x,y,z)`：
    
    *   `i=floor((x-min_x)/voxel_size)`
        
    *   `j=floor((y-min_y)/voxel_size)`
        
    *   `k=floor((z-min_z)/voxel_size)`
        
2.  用`(i,j,k)`作为key，把这个高斯的index放进一个字典（哈希表）
    
    *   key:`(i,j,k)`
        
    *   value:一个高斯索引列表
        

这样我们不会真的分配一个`nx*ny*nz`的稠密3D数组（可能会很大），而是只记录actually占用的体素。场景通常是稀疏的，这样会节省内存。

> 备注：这一点很重要。真实户外/广场场景的包围盒可能是几十米甚至上百米，稠密0.2m体素会爆内存。哈希体素（sparsevoxelmap）可以避免这个问题。

### 3.4体素特征计算

对于每个体素key`(i,j,k)`，我们要算两类指标：

1.  **密度指标：**
    
    *   `count`=这个体素里高斯的数量  
        你也可以归一化成“数量/体素体积”，不过体素体积是常数(`voxel_size^3`)，所以没必要；直接用数量即可。
        
2.  **高斯平均体积指标：**  
    我们需要一个“这个体素里的高斯是不是很细”的度量，来保护细杆子、路灯、旗杆那类孤立结构。
    
    对单个高斯的“体积”可以用它的主轴尺度乘积近似：
    
    *   `gaussian_volume≈sx*sy*sz`
        
        直觉：
        
    *   近处、被充分观察到的几何会用很多又小又尖锐的高斯，`sx,sy,sz`都比较小→乘积小。
        
    *   远处杂乱背景会用几个巨大、胖乎乎的高斯去糊→尺度大→乘积大。
        
        对体素内所有高斯：
        
    *   `avg_volume=mean(gaussian_volume)`（或者中位数也可以，更稳健）
        

我们会用`avg_volume`来判断“这格子虽然稀疏，但是不是包含很高精度的小结构”。

同时把每个体素的这些统计都保存下来，供后续阈值判断用。

---

## 4.体素级别的第一次分类（保留/丢弃）

### 4.1基于密度的筛选

我们需要确定“高密度是什么级别”。做法：

1.  收集所有体素的`count`。
    
2.  找到一个“参考高密度值”。一个稳妥的办法是：

*   把所有`count`从大到小排序，
    
*   取排名前若干百分位（脚本默认`density_reference_percentile=0.10`，即前10%）的平均值或中位数，叫它`count_ref`。
        
        *   直觉：这些就是“真的被重点扫过的区域”的典型密度。
            
3.  设定密度阈值：
    
*   `count_threshold=density_keep_ratio*count_ref`
    
*   例如当前默认`density_keep_ratio=0.3`就是“只要达到核心高密度区域的大约三成，我也认为它够重要”。
        

如果一个体素的`count>=count_threshold`，则标记为“KEEP\_BY\_DENSITY=True”。

这样就筛出一大块我们最关心的广场主体。

### 4.2基于细节（高斯体积）的补救

这个是用来保护“单根柱子/灯杆/薄栏杆”场景的。它们的问题是：

*   count可能很低（因为真就只有一小撮点）
    
*   但是那些高斯都很小很尖锐（代表高精细结构，值得保留）
    

做法：

1.  收集所有体素的`avg_volume`。
    
2.  找出“高精细”的参考体积：

*   将所有`avg_volume`排序（从小到大，因为越小=越细致），
    
*   取前若干百分位（默认`volume_reference_percentile=0.15`，即最小15%）的平均值或中位数，叫它`volume_ref`。
        
3.  设定体积阈值：
    
    *   `volume_threshold=volume_keep_ratio*volume_ref`
        
    *   注意这里的乘法方向要想清楚：
        
        *   体素越精细，`avg_volume`越小。
            
        *   我们希望保留那些“跟最精细区域差不多小”的体素。
            
*   如果`volume_keep_ratio=3.0`（脚本当前默认），意思是“只要这个体素的avg\_volume不比核心超细区域的大三倍，我也保留”。
        

最终规则：

*   如果一个体素`count<count_threshold`（按密度本来会被丢），但是`avg_volume<=volume_threshold`，则仍然标记为“KEEP\_BY\_DETAIL=True”。
    

这一步就是把“细杆子”从命运里救回来。

### 4.3合并规则

综合判断后，一个体素的初始keepflag可以这样定义：

*   `voxel.keep_raw=KEEP_BY_DENSITYORKEEP_BY_DETAIL`
    

也就是：密度很高的体素必须保留；如果密度不高但它的高斯都特别小，也保留；剩下的全部标记成丢弃候选。

---

## 5.空间膨胀(halo保护带)

第二个想法是“让重要区域的周边不要被一下子砍光”。直觉上，如果一个体素是KEEP，它附近一圈（例如1~2个体素半径）也应该KEEP，哪怕那一圈自己看起来不够dense/细。这是为了防止硬切出很难看的“断边”，还能稍微保留过渡区域（比如地面平坦区域/广场边线）。

实现方式可以想成3D形态学膨胀（morphologicaldilation）：

1.  建立一个稀疏集合：所有`voxel.keep_raw==True`的体素坐标`(i,j,k)`。
    
2.  对每个这样的`(i,j,k)`，把它立方邻域内、距离在`halo_voxels`内的所有体素都标记成`keep_final=True`。
    
    *   例如`halo_voxels=1`就是把3×3×3邻域都标记保留。
        
    *   `halo_voxels=2`就是5×5×5这样的邻域。
        
    *   记得把这个“体素步数”转成物理厚度：保护带厚度约等于`halo_voxels*voxel_size`。体素缩小时，要同步增大`halo_voxels`才能维持同等范围（例如`voxel_size=0.25m`,`halo_voxels=3`≈0.75m）。
        
3.  所有没有被标记的体素，`keep_final=False`。
    

几个注意点：

*   由于我们是用稀疏哈希体素存数据的，邻域里可能包含原来根本没出现过的体素key。这两种选择都可以：
    
    *   **保守做法（推荐）**：只有那些“原本存在至少一个高斯”的体素才有意义，所以只对现有体素做膨胀。也就是邻域循环的时候，只标记那些真实存在于字典里的体素。
        
    *   激进做法：把邻域里那些原本没高斯的体素也注册成keep\_final=True，但其实它里面没高斯，最后也不会影响输出，所以区别不大。
        
*   这个膨胀操作就是你脑子里“3D卷积”的核心。可以把它理解为对`keep_raw`这个三维0/1体素网格做一个max-filter/dilation核。
    

### 5.1 剔除孤立小岛（连通性过滤）

膨胀之后，远处仍可能残留一些独立的小孤岛。脚本现在默认在体素层面做一次6邻域连通分量分析：

1.  把`keep_final==True`的体素作为节点，按照6邻居（共享面体素）做BFS/DFS划分连通块。
2.  统计每个连通块的体素数量，只保留最大的那一个，其余全部清除。
3.  如果用户确实要保留所有离散结构，可以通过`--disable-component-filter`跳过这一步。

这个步骤对户外大场景特别有效：主体广场通常是最大的连通块，而远处码头、山体噪声会自动被剔除。

---

## 6.回写到高斯级别并做最终过滤

到这一步，每个体素`(i,j,k)`都有了`keep_final`(True/False)。

现在我们可以决定每个高斯的命运：

*   找出它所在的体素`(i,j,k)`；
    
*   如果该体素的`keep_final==True`，这个高斯就保留；
    
*   否则就删除。
    

于是我们拿到“裁剪后”的高斯子集，这就是最终想要保留的核心广场区域。

### 6.1限制高斯最大数量(可选参数)

如果提供了`max_gaussians`，并且保留下来的高斯数量依然太多（大于这个上限），就需要再压缩。

有两种策略：

**策略A（当前）：简单随机下采样。**

*   直接随机丢弃一部分高斯，直到数量满足`max_gaussians`。
    
*   好处：实现简单。
    
*   坏处：可能丢掉一些关键的高精细结构。
    

**策略B（未来）：基于体素的优先级采样。**

*   优先保留密度更高、`avg_volume`更小的体素里的高斯。
    
*   也就是说，给每个体素一个优先级分数，例如  
    `priority=alpha*normalized_density+beta*(1-normalized_avg_volume)`  
    先保留高优先级体素，再保留低优先级，直到达到上限。
    
*   这个策略更聪明，但实现稍复杂。
    

我们先规定策略A作为默认，策略B作为以后可选优化路径，暂时不使用。

---

## 7.输出

### 7.1写回裁剪后的3DGS

把保留下来的高斯重新写成一个新的.ply，字段保持一致，顺序保持一致。

*   重要：不能破坏下游渲染工具的兼容性，所以列名、数据类型、坐标系都要不变。
    
*   只是删了行，没有改格式。
    

这样就拿到了“核心区域版”的3DGS，可以直接用下游流程（比如继续喂给MILo的mesh优化管线）。

### 7.2导出OBJ/STL（未来可选，现在不做）

这是额外bonus。

3DGS本质上是体渲染基元（高斯体），不是显式网格。导出OBJ/STL不是“简单转格式”，而是“从这些高斯估一个表面”。有几种可行路线：

**路线1：点云重建+表面重建**

1.  用保留高斯的中心点`(x,y,z)`作为点云。
    
    *   按不透明度/alpha过滤掉非常透明的高斯，避免把远处背景噪声当成表面。
        
2.  对点云做法线估计（比如用邻域PCA的方式，工程里在实现这一块时可以直接用常规点云法线估计算法）。
    
3.  用泊松表面重建（PoissonSurfaceReconstruction）或MarchingCubes/MarchingTetrahedra风格重建成三角网格。
    
4.  得到三角网格后：
    
    *   导出为OBJ（可以顺带写顶点颜色作为vertexcolor）。
        
    *   导出为STL（只位置+三角面法线，标准STL没有颜色/纹理）。
        

**路线2：调用MILo里的mesh优化/clean\_convert\_mesh流程**

*   如果已经有从高斯/深度监督到显式mesh的那条pipeline（比如把高斯渲染成深度，再优化SDF/mesh），那么可以直接把“裁剪后3DGS”当成输入场景，只对裁剪后的区域跑MILo的mesh优化，最后再用你现有的`clean_convert_mesh.py`那类脚本转出.obj和.stl。
    
*   这个路线质量通常更高，尤其是表面会更干净连续，而且颜色/纹理能和MILo的渲染一致。但是需要已经能跑MILo的后半段优化。
    

目前先做路线1.

---

## 8.参数与默认值建议

下面是建议的主参数及最新默认值，并附上调参要点：

*   `voxel_size`  
    默认`0.25`米。越小越能捕捉薄片、屋顶等细节，但体素数量会激增；压到`0.2`以下要留意内存。缩小时要同步考虑`halo_voxels`的物理厚度（`halo_voxels*voxel_size`）。
    
*   `density_keep_ratio`  
    默认`0.30`。越小越宽松，适合扫描稀疏的屋顶/地面；越大越保守，适合密集但想大量裁剪的场景。
    
*   `density_reference_percentile`  
    默认`0.10`。表示使用最密的前10%体素估计`count_ref`。增大它→参考值更“平均”，适合整体密度变化大的场景；缩小它→只看最密集核心，参考值会更高。
    
*   `volume_keep_ratio`  
    默认`3.0`。放宽体素平均体积的上限，用来保护细结构；如果发现远处大泡泡被误判为“细节”而保留下来，可以把这个比值降到2.0甚至1.5。
    
*   `volume_reference_percentile`  
    默认`0.15`，即取最小15%的`avg_volume`来估计`volume_ref`。降低该值会让参考值更极端（更小），对细节更挑剔；提高则可以让更多“偏细”的体素受保护。
    
*   `halo_voxels`  
    默认`3`。物理厚度大约是`0.25m*3≈0.75m`。如果`voxel_size`调到`0.4`，可以把`halo_voxels`降到2维持差不多的过渡宽度；反之如果`voxel_size=0.2`，可以把`halo_voxels`上调到4。
    
*   `max_gaussians`  
    默认`None`（不限制）。如果场景仍过大，可设一个目标上限触发随机下采样。
    
*   `disable_component_filter`  
    默认`False`，即执行6邻域连通性清理，仅保留最大连通块。只有在场景确实存在多个需要保留的独立主体时，才建议打开这个开关。

调参时可以按以下顺序尝试：

1.  如果屋顶/地板仍然缺失：先把`voxel_size`降一些，同时按比例增大`halo_voxels`，必要时再下调`density_keep_ratio`或提高`volume_keep_ratio`。
2.  如果远处噪声仍残留：确认连通性过滤未被关闭；如主体和噪声连在一起，可适当调高`density_keep_ratio`或降低`volume_keep_ratio`。
3.  如果整体保留率过高：先提高`density_keep_ratio`，再考虑减小`halo_voxels`或调低`volume_reference_percentile`让细节守护更严格。
    

---

## 9.质量控制/调试指标

实现时，输出一些统计和可视化指标，帮助我们验证阈值是不是合理：

1.  **基本计数：**
    
    *   原始高斯数量
        
    *   过滤后高斯数量
        
    *   最终写出的高斯数量（在`max_gaussians`下采样之后）
        
2.  **体素统计直方图：**
    
    *   `count`的分布（min/median/95thpercentile/max）
        
    *   `avg_volume`的分布（min/median/95thpercentile/max）
        
    *   `count_ref`,`count_threshold`,`volume_ref`,`volume_threshold`的具体数值  
        这样可以肉眼判断这个阈值是不是离谱。
        
3.  **体素保留比例：**
    
    *   有多少体素`keep_raw==True`
        
    *   经过halo膨胀后，有多少体素`keep_final==True`
        
    *   这个比例能告诉你halo有没有过度扩张（如果halo\_voxels太大，最后可能几乎全保留，那就失去意义了）。
        
    *   体素计算要抛弃原本是空白的体素。
        
4.  **连通分量统计：**
    
    *   连通分量总数，以及最大分量的体素数量。
        
    *   这些数字可以验证组件过滤是否按预期运行，例如主体应明显大于其他分量。
        

---

## 10.边界情况与注意事项

1.  **尺度单位**  
    `voxel_size`和高斯的`(sx,sy,sz)`必须跟世界坐标在同一个单位系（通常是米）。  
    如果输入3DGS用的是别的缩放（比如毫米），记得统一到同一尺度，否则`avg_volume`会变得毫无意义，可以增加一步输出检查。
    
2.  **透明/半透明背景**  
    有些高斯可能是远处背景天空/水面的“雾”，这些常常高体积+低密度，会被自动清理掉，这是我们想要的效果。  
    如果你发现某些远景其实也很重要（比如码头某一部分也想保留），可以人为提高`halo_voxels`，或者事后手动加白名单体素（参见下面第3点）。
    
3.  **手动保留区/黑名单区（将来扩展，现在不做）**  
    脚本可以留接口，允许用户提供一个额外的boundingbox列表：
    
    *   “这几个box一律保留”
        
    *   “这几个box一律删除”  
        这样可以在完全自动之外，叠加工程师的人工判断。
        
4.  **连接性后处理（已实现，可关闭）**  
    现在脚本默认在halo之后执行6邻域连通分量分析，保留最大连通块、剔除远处孤岛。这一步很适合户外大场景。如果确实有多块主体需要保留，可以通过`--disable-component-filter`跳过。
        
5.  **OBJvsSTL的期望**
    
    *   `.obj`能带顶点颜色（每个顶点一个rgb），可在Blender里直接看个大概颜色。
        
    *   `.stl`是无颜色的实体网格，主要给后续几何处理/打印/碰撞检测用。  
        用户如果打开.stl看到灰色模型没有贴图，这是正常的，不是bug。
        
6.  **精细杆类结构的极端情况**  
    即使我们通过`avg_volume`把它救回来，还是可能因为下游Poisson重建时点太少导致网格断裂。  
    这种结构（路灯杆、旗杆、细栏杆）本来就难重建成封闭水密网格，这个不是本脚本能完美解决的，但至少我们不会把它们提前删掉。
    

---

## 11.总结性说明（给未来自己或合作同学看的）

*   这整个流程的核心思想是：  
    **用体素化统计来近似“扫描关注度/重建可靠度”，然后用形态学膨胀来给高价值区域一个安全边界。**
    
*   关键的两个指标：
    
    1.  体素内高斯数量（密度）：高→说明这个地方被大量近距离地拍过，通常是主广场。
        
    2.  体素内高斯平均体积：小→说明这些高斯本身是高分辨率的，通常代表近景的真实结构，而不是远处糊的一坨。
        
*   第一次筛选用的是一个“相对阈值”（相对于场景本身的top区域），而不是一个固定“count>=20就保留”。  
    这是为了让脚本对不同场景自适应：如果你的场景整体都很高密度，那阈值会相应变高；如果整体都稀疏，阈值就会下降。
    
*   halo步骤（3Ddilation）就是你设想的“卷积保护”，防止切得太硬，也让广场边缘保留下来而不是被一刀切掉。`voxel_size`越小，记得同步调大`halo_voxels`，脚本当前默认组合是0.25m×3≈0.75m的保护带。

*   连通性过滤会自动保留最大的连通块，清除远处小岛；只有在场景确实包含多个独立主体时才需要用`--disable-component-filter`关闭。
    
*   输出阶段，.ply只是删行，尽量不改schema，这样MILo后面的mesh优化、渲染等都能无缝接着跑。
    
*   网格导出的两条路线（未来）：
    
    *   快速但粗糙的点云→Poisson→OBJ/STL
        
    *   或者把裁剪后结果喂给MILo的mesh优化管线，拿高质量mesh，再用已有的`clean_convert_mesh`风格脚本去导出最终OBJ/STL。
        

---
